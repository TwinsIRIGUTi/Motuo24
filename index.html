<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>モツオ24</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    body {
      background: #111;
      color: #fff;
      font-family: "Kosugi Maru", sans-serif;
      margin: 0;
      padding: 0;
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      background: #111;
      display: block;
      margin: 10px auto;
      border-radius: 6px;
      touch-action: none;
    }
    #ui {
      text-align: center;
    }
    button {
      font-size: 1em;
      padding: 10px 20px;
      margin: 5px;
      border: none;
      border-radius: 6px;
      background: #333;
      color: #fff;
    }
    #wordDisplay {
      color: gold;
      font-size: 1.4em;
      height: 1.5em;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <div id="ui">
    <h1>モツオ24</h1>
    <div id="scoreDisplay">スコア: 0</div>
    <div id="wordDisplay"></div>
    <canvas id="game" width="320" height="320"></canvas>
    <button onclick="resetGame()">リセット</button>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const BLOCK_SIZE = 80;
    const GRID = 4;
    const kanaList = [..."ア,イ,ウ,エ,オ,カ,ガ,キ,ク,コ,サ,シ,ス,セ,ソ,タ,チ,ツ,テ,ト,ナ,ニ,ヌ,ネ,ノ,ハ,ヒ,フ,ヘ,ホ,マ,ミ,ム,メ,モ,ヤ,ユ,ヨ,ラ,リ,ル,レ,ロ,ワ,ヲ,ン".split(",")];
    const words = ["シロ","レバ","ガツ","ツル","ホネ","ハツ","アブラ","カシラ","ビール","ニコミ","シンキ","ウメワリ","サイダー","タンナマ","オシンコ","ダイコン","ナンコツ","コブクロ","ブドウワリ","ウイスキー","ツインズ"];

    let grid = [];
    let score = 0;
    let startX, startY;

    function createBlock() {
      return kanaList[Math.floor(Math.random() * kanaList.length)];
    }

    function resetGame() {
      score = 0;
      grid = [];
      for (let y = 0; y < GRID; y++) {
        const row = [];
        for (let x = 0; x < GRID; x++) {
          row.push(createBlock());
        }
        grid.push(row);
      }
      updateScore();
      draw();
    }

    function updateScore() {
      document.getElementById("scoreDisplay").textContent = "スコア: " + score;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < GRID; y++) {
        for (let x = 0; x < GRID; x++) {
          ctx.fillStyle = "#fff5cc";
          ctx.fillRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
          ctx.fillStyle = "#000";
          ctx.font = "32px sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(grid[y][x], x * BLOCK_SIZE + BLOCK_SIZE / 2, y * BLOCK_SIZE + BLOCK_SIZE / 2);
        }
      }
    }

    function checkWords() {
      let matched = [];
      // 横
      for (let y = 0; y < GRID; y++) {
        let line = grid[y].join('');
        for (let word of words) {
          let i = line.indexOf(word);
          if (i !== -1) {
            for (let k = 0; k < word.length; k++) matched.push(`${i + k},${y}`);
            score += word.length * 10;
            showWord(word);
          }
        }
      }
      // 縦
      for (let x = 0; x < GRID; x++) {
        let line = grid.map(row => row[x]).join('');
        for (let word of words) {
          let i = line.indexOf(word);
          if (i !== -1) {
            for (let k = 0; k < word.length; k++) matched.push(`${x},${i + k}`);
            score += word.length * 10;
            showWord(word);
          }
        }
      }
      // 補充
      let unique = [...new Set(matched)];
      for (let id of unique) {
        const [x, y] = id.split(',').map(Number);
        grid[y][x] = createBlock();
      }
      updateScore();
      draw();
    }

    function showWord(w) {
      const el = document.getElementById("wordDisplay");
      el.textContent = w;
      setTimeout(() => el.textContent = "", 1000);
    }

    function move(dx, dy) {
      let x = startX, y = startY;
      const tx = x + dx;
      const ty = y + dy;
      if (tx < 0 || tx >= GRID || ty < 0 || ty >= GRID) return;
      [grid[y][x], grid[ty][tx]] = [grid[ty][tx], grid[y][x]];
      startX = tx; startY = ty;
      draw();
      checkWords();
    }

    // タッチ対応（フリックで移動）
    canvas.addEventListener("touchstart", e => {
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0];
      const x = Math.floor((t.clientX - rect.left) / BLOCK_SIZE);
      const y = Math.floor((t.clientY - rect.top) / BLOCK_SIZE);
      startX = x; startY = y;
    });

    canvas.addEventListener("touchend", e => {
      const rect = canvas.getBoundingClientRect();
      const t = e.changedTouches[0];
      const endX = (t.clientX - rect.left);
      const endY = (t.clientY - rect.top);
      const dx = endX - startX * BLOCK_SIZE - BLOCK_SIZE / 2;
      const dy = endY - startY * BLOCK_SIZE - BLOCK_SIZE / 2;
      if (Math.abs(dx) > Math.abs(dy)) {
        move(dx > 0 ? 1 : -1, 0);
      } else {
        move(0, dy > 0 ? 1 : -1);
      }
    });

    resetGame();
  </script>
</body>
</html>
