<!-- ※ 省略部分あり。冒頭の HTML/CSS はそのまま -->

<canvas id="game" width="500" height="500" tabindex="0"></canvas>
<button onclick="reloadBoard()">リロード</button>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const BLOCK_SIZE = 100;
const GRID_SIZE = 5;
const EMPTY = null;
let board = [];
let score = 0;
let cursor = { x: 0, y: 0 };

const words = [ "シロ", "レバ", "ガツ", "コブクロ", "ナンコツ", "アブラ", "ハツ", "カシラ", "ビール", "ウメワリ", "ブドウワリ", "ウイスキー", "サイダー", "ツル", "シンキ", "タンナマ", "オシンコ", "ダイコン", "ニコミ", "ホネ", "ツインズ" ];

function createWeightedKanaList(words) {
  let freq = {};
  for (let word of words) {
    for (let char of word) {
      freq[char] = (freq[char] || 0) + 1;
    }
  }
  let list = [];
  for (let [char, count] of Object.entries(freq)) {
    for (let i = 0; i < count; i++) list.push(char);
  }
  return list;
}

const kanaList = createWeightedKanaList(words);

function getRandomKana() {
  return kanaList[Math.floor(Math.random() * kanaList.length)];
}

function createBlock() {
  return { char: getRandomKana() };
}

function initBoard() {
  board = [];
  for (let y = 0; y < GRID_SIZE; y++) {
    const row = [];
    for (let x = 0; x < GRID_SIZE; x++) {
      row.push(createBlock());
    }
    board.push(row);
  }
  // 空白を1マス作成（ランダム）
  const emptyX = Math.floor(Math.random() * GRID_SIZE);
  const emptyY = Math.floor(Math.random() * GRID_SIZE);
  board[emptyY][emptyX] = EMPTY;
}

function reloadBoard() {
  initBoard();
  drawBoard();
}

function drawBoard() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      const block = board[y][x];
      ctx.fillStyle = block ? "#fff5cc" : "#111";
      ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
      if (block) {
        ctx.fillStyle = "#000";
        ctx.font = "48px Kosugi Maru";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(block.char, x * BLOCK_SIZE + BLOCK_SIZE / 2, y * BLOCK_SIZE + BLOCK_SIZE / 2);
      }
    }
  }
}

function findEmpty() {
  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      if (board[y][x] === EMPTY) return { x, y };
    }
  }
  return null;
}

function isAdjacent(x1, y1, x2, y2) {
  return (Math.abs(x1 - x2) + Math.abs(y1 - y2)) === 1;
}

canvas.addEventListener("click", function (e) {
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left) / BLOCK_SIZE);
  const y = Math.floor((e.clientY - rect.top) / BLOCK_SIZE);
  const empty = findEmpty();
  if (isAdjacent(x, y, empty.x, empty.y)) {
    const temp = board[y][x];
    board[y][x] = EMPTY;
    board[empty.y][empty.x] = temp;
    drawBoard();
    checkWords();
  }
});

function checkWords() {
  let foundWords = [];
  let positionsToClear = [];

  // 横チェック
  for (let y = 0; y < GRID_SIZE; y++) {
    let line = "";
    for (let x = 0; x < GRID_SIZE; x++) {
      line += board[y][x] ? board[y][x].char : "";
    }
    for (const word of words) {
      const idx = line.indexOf(word);
      if (idx !== -1) {
        foundWords.push(word);
        for (let i = 0; i < word.length; i++) {
          positionsToClear.push({ x: idx + i, y });
        }
      }
    }
  }

  // 縦チェック
  for (let x = 0; x < GRID_SIZE; x++) {
    let line = "";
    for (let y = 0; y < GRID_SIZE; y++) {
      line += board[y][x] ? board[y][x].char : "";
    }
    for (const word of words) {
      const idx = line.indexOf(word);
      if (idx !== -1) {
        foundWords.push(word);
        for (let i = 0; i < word.length; i++) {
          positionsToClear.push({ x, y: idx + i });
        }
      }
    }
  }

  if (foundWords.length > 0) {
    const unique = new Set();
    for (let pos of positionsToClear) {
      if (!unique.has(`${pos.x},${pos.y}`)) {
        board[pos.y][pos.x] = createBlock();
        unique.add(`${pos.x},${pos.y}`);
      }
    }
    drawBoard();
  }
}

initBoard();
drawBoard();
</script>
